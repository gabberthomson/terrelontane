<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Terre Lontane - Assistente</title>

  <!-- Bootstrap (solo CSS) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root {
      --bg-overlay: rgba(0, 0, 0, 0.35);
      --panel: rgba(255, 255, 255, 0.92);
      --bubble-ai: rgba(255, 255, 255, 0.96);
      --bubble-user: rgba(13, 110, 253, 0.10);
      --border: rgba(0,0,0,0.10);
    }

html, body {
  height: 100%;
  width: 100%;
}

body {
  margin: 0;

  /* Background full-page (come già fai) */
  background: #0b1220;
  background-image:
    linear-gradient(var(--bg-overlay), var(--bg-overlay)),
    radial-gradient(circle at 20% 10%, rgba(255,255,255,0.10), transparent 35%),
    radial-gradient(circle at 80% 30%, rgba(255,255,255,0.08), transparent 40%),
    radial-gradient(circle at 40% 90%, rgba(255,255,255,0.06), transparent 45%);
  background-size: cover;
  background-position: center;

  /* Evita “rimbalzo” senza bloccare la gestione della viewport */
  overflow: clip;
  overscroll-behavior: none;

  /* Fallback viewport: svh/dvh dove possibile */
  min-height: 100vh;
  min-height: 100svh;
}

@supports (height: 100dvh) {
  body { min-height: 100dvh; }
}

.app-shell {
  /* Altezza app: usa JS fallback quando serve, altrimenti svh/dvh */
  height: var(--app-height, 100vh);
  min-height: 100vh;
  min-height: 100svh;

  /* Desktop containment */
  width: 100%;
  max-width: 980px;
  margin: 0 auto;

  display: flex;
  flex-direction: column;
  gap: 12px;

  /* Spaziatura + safe-area */
  padding: 12px;
  padding-bottom: calc(12px + env(safe-area-inset-bottom));
}

@supports (height: 100dvh) {
  .app-shell {
    height: var(--app-height, 100dvh);
    min-height: 100dvh;
  }
}

    .topbar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      flex: 0 0 auto;
    }

    .chat-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      backdrop-filter: blur(6px);
      overflow: hidden;
      flex: 1 1 auto;

      /* importante per avere chat + composer senza tagli */
      display: flex;
      flex-direction: column;
      min-height: 0; /* fondamentale per overflow corretto nei flex */
    }

.chat-scroll {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  padding: 14px 14px 10px 14px;
  -webkit-overflow-scrolling: touch;

  /* IMPORTANTISSIMO: spazio di scroll per non coprire l’ultima bolla */
  padding-bottom: calc(14px + var(--composer-h, 92px) + env(safe-area-inset-bottom));
  scroll-padding-bottom: calc(14px + var(--composer-h, 92px) + env(safe-area-inset-bottom));
}


    .msg-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }

    .msg-row.ai { justify-content: flex-start; }
    .msg-row.user { justify-content: flex-end; }

    .bubble {
      max-width: min(780px, 92%);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px 12px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .bubble.ai { background: var(--bubble-ai); }
    .bubble.user { background: var(--bubble-user); font-style: italic; }

    .composer {
      flex: 0 0 auto;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.96);

      /* “sticky” dentro la card: resta visibile senza coprire contenuto */
      position: sticky;
      bottom: 0;
      padding: 10px 12px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
  position: sticky;
  bottom: 0;
  z-index: 5; /* sopra le bolle */
  }

    textarea.form-control {
      resize: none;
      min-height: 52px;
      max-height: 160px;
    }

    .hint {
      font-size: 12px;
      opacity: 0.72;
    }

    .spinner {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 2px solid rgba(0,0,0,0.15);
      border-top-color: rgba(0,0,0,0.55);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: -3px;
      margin-right: 6px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Piccolo tuning per mobile */
    @media (max-width: 576px) {
      .app-shell { padding: 10px; gap: 10px; }
      .topbar { border-radius: 14px; }
      .chat-card { border-radius: 14px; }
      .bubble { max-width: 94%; }
    }
  </style>
</head>

<body>
  <div class="app-shell">
    <!-- Top bar -->
    <div class="topbar d-flex align-items-center justify-content-between gap-2">
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <strong>Terre Lontane</strong>
        <span class="text-muted">Assistente</span>

        <!-- Link statico (attenzione: se il PDF è privato, non può stare su GitHub Pages senza protezione) -->
        <a id="manualLink" class="btn btn-sm btn-outline-secondary"
           href="./risorse_terre_lontane.pdf" target="_blank" rel="noopener">
          Scarica risorse (PDF)
        </a>
      </div>

      <div class="d-flex align-items-center gap-2">
        <button id="btnNew" class="btn btn-sm btn-primary">Nuova chat</button>
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-card">
      <div id="chat" class="chat-scroll"></div>

      <!-- Composer -->
      <div class="composer">
        <div class="input-group">
          <textarea id="input" class="form-control" placeholder="Scrivi qui..."></textarea>
          <button id="btnSend" class="btn btn-success px-3">Invia</button>
        </div>
        <div class="d-flex justify-content-between mt-2">
          <div class="hint">Invio = invia • Ctrl+Invio = a capo</div>
          <div id="status" class="hint text-end"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // CONFIG
    // =========================
    const WORKER_BASE_URL = "https://terrelontane.gabbriellini.workers.dev"; // <-- verifica dominio
    const STORAGE_KEY = "tl_sid_v1";

    // =========================
    // SYSTEM PROMPT
    // =========================
    const SYSTEM_PROMPT = `Sei l’assistente ufficiale del gioco di ruolo “Terre Lontane”.

Per OGNI domanda dell’utente devi seguire questo processo:

Determina la modalità della domanda:

REGOLA → chiarimenti su regole, meccaniche, abilità, oggetti, combattimento, magie, tiri, mostri già esistenti.

IDEE → spunti creativi: avventure, ambientazioni, PNG, nuovi mostri, oggetti inventati.

MISTA → una parte di regole + una parte creativa.

Usa SEMPRE il tool file_search sul manuale di “Terre Lontane” prima di rispondere.

MODALITÀ REGOLA:

Rispondi SOLO usando informazioni presenti negli estratti recuperati con file_search.

NON inventare regole, numeri, eccezioni o interpretazioni.

Se non trovi la risposta negli estratti, dì:
“Questa informazione non è presente nel manuale di Terre Lontane”.

NON proporre house rule.

MODALITÀ IDEE:

Usa gli estratti come canone (tono, ambientazione, meccaniche).

Poi proponi idee pratiche e subito giocabili.

Se fai assunzioni non presenti, dichiaralo.

MODALITÀ MISTA:

Dividi in “Regole” (solo manuale) e “Idee” (creative ma coerenti).

Inizia SEMPRE indicando la modalità: “Modalità: REGOLA / IDEE / MISTA”.`;

    // =========================
    // DOM
    // =========================
    const chatEl = document.getElementById("chat");
    const inputEl = document.getElementById("input");
    const statusEl = document.getElementById("status");
    const btnSend = document.getElementById("btnSend");
    const btnNew = document.getElementById("btnNew");

    // =========================
    // STATE
    // =========================
    let sessionId = localStorage.getItem(STORAGE_KEY) || "";
    let isBusy = false;

    // =========================
    // UI helpers
    // =========================
    function setBusy(busy, text) {
      isBusy = busy;
      btnSend.disabled = busy;
      btnNew.disabled = busy;
      inputEl.disabled = busy;
      statusEl.textContent = text || "";
    }

    function scrollToBottom() {
      // requestAnimationFrame riduce glitch su mobile
      requestAnimationFrame(() => { chatEl.scrollTop = chatEl.scrollHeight; });
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m) => ({
        "&":"&amp;", "<":"&lt;", ">":"&gt;", "\"":"&quot;", "'":"&#039;"
      }[m]));
    }

    function addMessage(role, text) {
      const row = document.createElement("div");
      row.className = `msg-row ${role}`;

      const bubble = document.createElement("div");
      bubble.className = `bubble ${role}`;
      bubble.innerHTML = escapeHtml(text);

      row.appendChild(bubble);
      chatEl.appendChild(row);
      scrollToBottom();
    }

    function addThinking() {
      const row = document.createElement("div");
      row.className = "msg-row ai";
      row.id = "thinking-row";

      const bubble = document.createElement("div");
      bubble.className = "bubble ai";
      bubble.innerHTML = `<span class="spinner"></span>Sto pensando...`;

      row.appendChild(bubble);
      chatEl.appendChild(row);
      scrollToBottom();
    }

    function removeThinking() {
      const el = document.getElementById("thinking-row");
      if (el) el.remove();
    }

    // =========================
    // API (compatibile col tuo worker: sessionId nel payload)
    // =========================
    async function postJson(path, bodyObj) {
      const res = await fetch(`${WORKER_BASE_URL}${path}`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(bodyObj || {}),
      });

      const txt = await res.text();
      let json = null;
      try { json = JSON.parse(txt); } catch { /* ignore */ }

      if (!res.ok) {
        const detail = json?.error || json?.detail || txt || `HTTP ${res.status}`;
        throw new Error(detail);
      }
      return json ?? {};
    }

    async function newSession() {
      const out = await postJson("/api/session/new", {});
      sessionId = out.sessionId || "";
      localStorage.setItem(STORAGE_KEY, sessionId);
      chatEl.innerHTML = "";
      addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
    }

    async function resetSessionIfAny() {
      if (!sessionId) return;
      await postJson("/api/session/reset", { sessionId });
      chatEl.innerHTML = "";
      addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
    }

    async function ensureSession() {
      if (sessionId) return sessionId;
      await newSession();
      return sessionId;
    }

    async function sendMessage() {
      const text = (inputEl.value || "").trim();
      if (!text || isBusy) return;

      setBusy(true, "");
      addMessage("user", text);
      inputEl.value = "";
      addThinking();

      try {
        const sid = await ensureSession();
        const out = await postJson("/api/chat", {
          sessionId: sid,
          message: text,
          systemPrompt: SYSTEM_PROMPT,
        });

        removeThinking();
        addMessage("ai", out.text || "(risposta vuota)");
      } catch (e) {
        removeThinking();
        addMessage("ai", `Errore: ${String(e.message || e)}`);
      } finally {
        setBusy(false, "");
        inputEl.focus();
      }
    }

    // =========================
    // Events
    // =========================
    btnSend.addEventListener("click", sendMessage);

    inputEl.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" && ev.ctrlKey) {
        // Ctrl+Invio = newline (default)
        return;
      }
      if (ev.key === "Enter" && !ev.ctrlKey && !ev.shiftKey) {
        ev.preventDefault();
        sendMessage();
      }
    });

    // Un solo bottone:
    // - se c'è sessione: reset
    // - se non c'è: new
    btnNew.addEventListener("click", async () => {
      if (isBusy) return;
      setBusy(true, "Avvio chat...");
      try {
        if (sessionId) {
          await resetSessionIfAny();
        } else {
          await newSession();
        }
      } catch (e) {
        addMessage("ai", `Errore: ${String(e.message || e)}`);
      } finally {
        setBusy(false, "");
        inputEl.focus();
      }
    });

    // Boot
    (function boot() {
      addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
      inputEl.focus();
      // opzionale: se vuoi partire sempre da sessione pulita sul device:
      // sessionId = "";
      // localStorage.removeItem(STORAGE_KEY);
    })();

(function setupViewportFixes() {
  const composer = document.querySelector(".composer");
  const chat = document.getElementById("chat");

  function setVars() {
    // 1) Altezza “visibile” reale (con tastiera): VisualViewport quando disponibile
    let h = window.innerHeight;
    if (window.visualViewport) h = Math.round(window.visualViewport.height);
    document.documentElement.style.setProperty("--app-height", h + "px");

    // 2) Misura altezza composer per padding-bottom del container chat
    if (composer) {
      const ch = Math.round(composer.getBoundingClientRect().height);
      document.documentElement.style.setProperty("--composer-h", ch + "px");
    }
  }

  function onResizeOrFocus() {
    setVars();
    // Se sto scrivendo, voglio che la chat resti “a fondo”
    if (chat) requestAnimationFrame(() => { chat.scrollTop = chat.scrollHeight; });
  }

  setVars();

  window.addEventListener("resize", onResizeOrFocus);
  window.addEventListener("orientationchange", onResizeOrFocus);

  // Eventi più affidabili su mobile quando entra/esce la tastiera
  window.addEventListener("focusin", onResizeOrFocus);
  window.addEventListener("focusout", onResizeOrFocus);

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", onResizeOrFocus);
    window.visualViewport.addEventListener("scroll", onResizeOrFocus);
  }
})();
</script>
</body>
</html>
