<!doctype html>
<html lang="it">
<head>
<link rel="manifest" href="manifest.json" />
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Terre Lontane - Assistente</title>

  <!-- Bootstrap (solo CSS) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Markdown renderer + HTML sanitizer (per output Gemini in markdown) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>

  <style>
    :root {
      --bg-overlay: rgba(0, 0, 0, 0.35);
      --panel: rgba(255, 255, 255, 0.92);
      --bubble-ai: rgba(255, 255, 255, 0.96);
      --bubble-user: rgba(13, 110, 253, 0.10);
      --border: rgba(0,0,0,0.10);
    }

    html, body {
      height: 100%;
      width: 100%;
    }

    body {
      margin: 0;

      /* Background full-page */
      background: #0b1220;
      background-image:
        linear-gradient(var(--bg-overlay), var(--bg-overlay)),
        radial-gradient(circle at 20% 10%, rgba(255,255,255,0.10), transparent 35%),
        radial-gradient(circle at 80% 30%, rgba(255,255,255,0.08), transparent 40%),
        radial-gradient(circle at 40% 90%, rgba(255,255,255,0.06), transparent 45%);
      background-size: cover;
      background-position: center;

      /* Evita rimbalzi e side effects con tastiera */
      overflow: clip;
      overscroll-behavior: none;

      min-height: 100vh;
      min-height: 100svh;
    }

    @supports (height: 100dvh) {
      body { min-height: 100dvh; }
    }

    .app-shell {
      height: var(--app-height, 100vh);
      min-height: 100vh;
      min-height: 100svh;

      width: 100%;
      max-width: 980px;
      margin: 0 auto;

      display: flex;
      flex-direction: column;
      gap: 12px;

      padding: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
    }

    @supports (height: 100dvh) {
      .app-shell {
        height: var(--app-height, 100dvh);
        min-height: 100dvh;
      }
    }

    .topbar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      flex: 0 0 auto;
    }

    .chat-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      backdrop-filter: blur(6px);
      overflow: hidden;
      flex: 1 1 auto;

      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-scroll {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding: 14px 14px 10px 14px;
      -webkit-overflow-scrolling: touch;

      /* spazio per non coprire l’ultima bolla */
      padding-bottom: calc(14px + var(--composer-h, 92px) + env(safe-area-inset-bottom));
      scroll-padding-bottom: calc(14px + var(--composer-h, 92px) + env(safe-area-inset-bottom));
    }

    .msg-row {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
    }

    .msg-row.ai { justify-content: flex-start; }
    .msg-row.user { justify-content: flex-end; }

    .bubble {
      max-width: min(780px, 92%);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px 12px;
      line-height: 1.35;
      word-break: break-word;
    }

    /* NB: togliamo white-space: pre-wrap qui: il markdown gestisce meglio spaziature/paragraph.
       Manteniamo word-break e gestiamo newline via marked (breaks=true). */
    .bubble.ai { background: var(--bubble-ai); }
    .bubble.user { background: var(--bubble-user); font-style: italic; white-space: pre-wrap; }

    /* Contenuto markdown dentro le bolle AI */
    .bubble .md {
      line-height: 1.45;
      word-wrap: break-word;
    }
    .bubble .md p { margin: 0.4em 0; }
    .bubble .md ul, .bubble .md ol { margin: 0.4em 0 0.4em 1.25em; }
    .bubble .md li { margin: 0.2em 0; }
    .bubble .md h1, .bubble .md h2, .bubble .md h3 {
      margin: 0.6em 0 0.3em;
      line-height: 1.2;
    }

    .bubble .md code {
      padding: 0.12em 0.35em;
      border-radius: 6px;
      background: rgba(0,0,0,0.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
    }
    .bubble .md pre {
      margin: 0.6em 0;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,0.12);
      overflow: auto;
    }
    .bubble .md pre code {
      background: transparent;
      padding: 0;
      font-size: 0.92em;
      display: block;
      white-space: pre;
    }

    .bubble .md table {
      border-collapse: collapse;
      margin: 0.6em 0;
      width: 100%;
      overflow: hidden;
      border-radius: 10px;
    }
    .bubble .md th, .bubble .md td {
      border: 1px solid rgba(0,0,0,0.12);
      padding: 8px 10px;
      vertical-align: top;
    }
    .bubble .md th {
      background: rgba(0,0,0,0.04);
    }

    .bubble .md a {
      color: inherit;
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .composer {
      flex: 0 0 auto;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.96);

      position: sticky;
      bottom: 0;
      z-index: 5;

      padding: 10px 12px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
    }

    textarea.form-control {
      resize: none;
      min-height: 52px;
      max-height: 160px;
    }

    .hint {
      font-size: 12px;
      opacity: 0.72;
    }

    .spinner {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 2px solid rgba(0,0,0,0.15);
      border-top-color: rgba(0,0,0,0.55);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      vertical-align: -3px;
      margin-right: 6px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    @media (max-width: 576px) {
      .app-shell { padding: 10px; gap: 10px; }
      .topbar { border-radius: 14px; }
      .chat-card { border-radius: 14px; }
      .bubble { max-width: 94%; }
    }
  </style>
</head>

<body>
  <div class="app-shell">
    <!-- Top bar -->
    <div class="topbar d-flex align-items-center justify-content-between gap-2">
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <strong>Terre Lontane</strong>
        <span class="text-muted">Assistente</span>

        <a id="manualLink" class="btn btn-sm btn-outline-secondary"
           href="./risorse_terre_lontane.pdf" target="_blank" rel="noopener">
          Scarica risorse (PDF)
        </a>
      </div>

      <div class="d-flex align-items-center gap-2">
        <button id="btnNew" class="btn btn-sm btn-primary">Nuova chat</button>
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-card">
      <div id="chat" class="chat-scroll"></div>

      <!-- Composer -->
      <div class="composer">
        <div class="input-group">
          <textarea id="input" class="form-control" placeholder="Scrivi qui..."></textarea>
          <button id="btnSend" class="btn btn-success px-3">Invia</button>
        </div>
        <div class="d-flex justify-content-between mt-2">
          <div class="hint">Invio = invia • Ctrl+Invio = a capo</div>
          <div id="status" class="hint text-end"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // CONFIG
    // =========================
    const WORKER_BASE_URL = "https://terrelontane.gabbriellini.workers.dev"; // <-- verifica dominio
    const STORAGE_KEY  = "tl_sid_v1";
    const HISTORY_KEY  = "tl_history_v1";  // array di { role, text } nel localStorage

    // =========================
    // SYSTEM PROMPT
    // =========================
    const SYSTEM_PROMPT = `Sei l’assistente ufficiale del gioco di ruolo “Terre Lontane”.
Per OGNI domanda dell’utente devi seguire questo processo:
Determina la modalità della domanda:
REGOLA → chiarimenti su regole, meccaniche, abilità, oggetti, combattimento, magie, tiri, mostri già esistenti.
IDEE → spunti creativi: avventure, ambientazioni, PNG, nuovi mostri, oggetti inventati.
MISTA → una parte di regole + una parte creativa.
Usa SEMPRE il tool file_search sul manuale di “Terre Lontane” prima di rispondere.
MODALITÀ REGOLA:
Rispondi SOLO usando informazioni presenti negli estratti recuperati con file_search.
NON inventare regole, numeri, eccezioni o interpretazioni.
Se non trovi la risposta negli estratti, dì:
“Questa informazione non è presente nel manuale di Terre Lontane”.
NON proporre house rule.
MODALITÀ IDEE:
Proponi idee pratiche e subito giocabili ma attieniti agli estratti recuperati con file_search per quanto riguarda le meccaniche di gioco, la geografia, magiue, armi e oggetti a disposizione degli avventuerieri. Se viene espressamente richiesto di inventare un mostro, un oggetto magico, una magia, un'ambientazione, fallo ma mantiene coerenza con lo stile e le meccaniche degli estratti recuperati con file_search.
MODALITÀ MISTA:
Dividi in “Regole” (solo manuale) e “Idee” (creative ma coerenti).
Inizia SEMPRE indicando la modalità: “Modalità: REGOLA / IDEE / MISTA”.`;

    // =========================
    // DOM
    // =========================
    const chatEl = document.getElementById("chat");
    const inputEl = document.getElementById("input");
    const statusEl = document.getElementById("status");
    const btnSend = document.getElementById("btnSend");
    const btnNew = document.getElementById("btnNew");

    // =========================
    // STATE
    // =========================
    let sessionId = localStorage.getItem(STORAGE_KEY) || "";
    let isBusy = false;

    // =========================
    // LOCAL HISTORY (full log)
    // =========================
    function loadHistory() {
      try { return JSON.parse(localStorage.getItem(HISTORY_KEY)) || []; }
      catch { return []; }
    }

    function appendHistory(role, text) {
      const h = loadHistory();
      h.push({ role, text });
      localStorage.setItem(HISTORY_KEY, JSON.stringify(h));
    }

    function clearHistory() {
      localStorage.removeItem(HISTORY_KEY);
    }

    // =========================
    // Markdown renderer (safe)
    // =========================
    function renderMarkdown(md) {
      if (!window.marked || !window.DOMPurify) {
        // Fallback: se CDN non carica, mostra plain text sicuro
        const div = document.createElement("div");
        div.textContent = md ?? "";
        return div.innerHTML;
      }

      // Config: newline => <br>, GFM
      marked.setOptions({ breaks: true, gfm: true });

      const rawHtml = marked.parse(md ?? "");

      // Sanitize: consenti HTML “normale” e blocca script/event handlers
      return DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true }
      });
    }

    // =========================
    // UI helpers
    // =========================
    function setBusy(busy, text) {
      isBusy = busy;
      btnSend.disabled = busy;
      btnNew.disabled = busy;
      inputEl.disabled = busy;
      statusEl.textContent = text || "";
    }

    function scrollToBottom() {
      requestAnimationFrame(() => { chatEl.scrollTop = chatEl.scrollHeight; });
    }

function scrollMessageToTop(rowEl, behavior = "smooth") {
  if (!rowEl) return;

  // calcola la posizione della riga rispetto al container scrollabile
  const chatRect = chatEl.getBoundingClientRect();
  const rowRect = rowEl.getBoundingClientRect();
  const y = (rowRect.top - chatRect.top) + chatEl.scrollTop;

  // piccolo margine per non attaccare il bubble al bordo
  const margin = 8;

  chatEl.scrollTo({
    top: Math.max(0, y - margin),
    behavior
  });
}

function addMessage(role, text) {
  const row = document.createElement("div");
  row.className = `msg-row ${role}`;

  const bubble = document.createElement("div");
  bubble.className = `bubble ${role}`;

  if (role === "ai") {
    const content = document.createElement("div");
    content.className = "md";
    content.innerHTML = renderMarkdown(text);
    bubble.appendChild(content);
  } else {
    bubble.textContent = text ?? "";
  }

  row.appendChild(bubble);
  chatEl.appendChild(row);

  scrollToBottom();
  return row; // <--- IMPORTANT
}

    function addThinking() {
      const row = document.createElement("div");
      row.className = "msg-row ai";
      row.id = "thinking-row";

      const bubble = document.createElement("div");
      bubble.className = "bubble ai";
      bubble.innerHTML = `<span class="spinner"></span>Sto pensando...`;

      row.appendChild(bubble);
      chatEl.appendChild(row);
      scrollToBottom();
    }

    function removeThinking() {
      const el = document.getElementById("thinking-row");
      if (el) el.remove();
    }

    // =========================
    // API (compatibile col tuo worker: sessionId nel payload)
    // =========================
    async function postJson(path, bodyObj) {
      const res = await fetch(`${WORKER_BASE_URL}${path}`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(bodyObj || {}),
      });

      const txt = await res.text();
      let json = null;
      try { json = JSON.parse(txt); } catch { /* ignore */ }

      if (!res.ok) {
        const detail = json?.error || json?.detail || txt || `HTTP ${res.status}`;
        throw new Error(detail);
      }
      return json ?? {};
    }

    async function newSession() {
      const out = await postJson("/api/session/new", {});
      sessionId = out.sessionId || "";
      localStorage.setItem(STORAGE_KEY, sessionId);
      clearHistory();
      chatEl.innerHTML = "";
      addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
    }

    async function resetSessionIfAny() {
      if (!sessionId) return;
      await postJson("/api/session/reset", { sessionId });
      clearHistory();
      chatEl.innerHTML = "";
      addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
    }

    async function ensureSession() {
      if (sessionId) return sessionId;
      await newSession();
      return sessionId;
    }

async function sendMessage() {
  const raw = inputEl.value || "";
  const text = raw.trim();
  if (!text || isBusy) return;

  setBusy(true, "");

  const userRow = addMessage("user", raw.trimEnd()); // <--- salva riferimento
  appendHistory("user", text);
  inputEl.value = "";
  inputEl.blur?.(); // se vuoi chiudere la tastiera

  addThinking();

  try {
    const sid = await ensureSession();
 //   const tsToken = await getTurnstileToken();

    const out = await postJson("/api/chat", {
      sessionId: sid,
      message: text,
      systemPrompt: SYSTEM_PROMPT,
//      turnstileToken: tsToken,
    });

    removeThinking();
    const aiText = out.text || "(risposta vuota)";
    addMessage("ai", aiText);
    appendHistory("ai", aiText);

    // <--- QUI: porta la domanda in alto
    // leggero delay per far “stabilizzare” layout/markdown
    requestAnimationFrame(() => scrollMessageToTop(userRow, "smooth"));

  } catch (e) {
    removeThinking();
    addMessage("ai", `Errore: ${String(e.message || e)}`);
    requestAnimationFrame(() => scrollMessageToTop(userRow, "smooth"));
  } finally {
    setBusy(false, "");
    const isMobileLike = matchMedia("(pointer: coarse)").matches;
    if (!isMobileLike) inputEl.focus();
  }
}


    // =========================
    // Events
    // =========================
    btnSend.addEventListener("click", sendMessage);

    inputEl.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" && ev.ctrlKey) {
        // Ctrl+Invio = newline (default)
        return;
      }
      if (ev.key === "Enter" && !ev.ctrlKey && !ev.shiftKey) {
        ev.preventDefault();
        sendMessage();
      }
    });

    btnNew.addEventListener("click", async () => {
      if (isBusy) return;
      setBusy(true, "Avvio chat...");
      try {
        if (sessionId) {
          await resetSessionIfAny();
        } else {
          await newSession();
        }
      } catch (e) {
        addMessage("ai", `Errore: ${String(e.message || e)}`);
      } finally {
        setBusy(false, "");
        inputEl.focus();
      }
    });

    // Boot
    (async function boot() {
      // Se c'è un sessionId, verifica che sia ancora valido sul server
      if (sessionId) {
        try {
          const res = await fetch(
            `${WORKER_BASE_URL}/api/session/history?sessionId=${encodeURIComponent(sessionId)}`
          );
          if (!res.ok) {
            // Sessione scaduta o non valida → pulisci tutto
            sessionId = "";
            localStorage.removeItem(STORAGE_KEY);
            clearHistory();
          }
        } catch {
          // Errore di rete → mantieni sessionId e history, l'utente riproverà
        }
      }

      const history = loadHistory();

      if (history.length > 0) {
        // Replay della storia completa dal localStorage
        for (const { role, text } of history) {
          if (!text) continue;
          addMessage(role === "ai" ? "ai" : "user", text);
        }
      } else {
        addMessage("ai", "Pronto. Fai una domanda su Terre Lontane.");
      }
      inputEl.focus();
    })();

    // Viewport / keyboard-safe sizing
    (function setupViewportFixes() {
      const composer = document.querySelector(".composer");
      const chat = document.getElementById("chat");

      function setVars() {
        let h = window.innerHeight;
        if (window.visualViewport) h = Math.round(window.visualViewport.height);
        document.documentElement.style.setProperty("--app-height", h + "px");

        if (composer) {
          const ch = Math.round(composer.getBoundingClientRect().height);
          document.documentElement.style.setProperty("--composer-h", ch + "px");
        }
      }

      function onResizeOrFocus() {
        setVars();
if (chat) {
  const nearBottom = (chat.scrollHeight - (chat.scrollTop + chat.clientHeight)) < 80;
  if (nearBottom) {
    requestAnimationFrame(() => { chat.scrollTop = chat.scrollHeight; });
  }
}
      }

      setVars();

      window.addEventListener("resize", onResizeOrFocus);
      window.addEventListener("orientationchange", onResizeOrFocus);
      window.addEventListener("focusin", onResizeOrFocus);
      window.addEventListener("focusout", onResizeOrFocus);

      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", onResizeOrFocus);
        window.visualViewport.addEventListener("scroll", onResizeOrFocus);
      }
    })();
  </script>
</body>
</html>
